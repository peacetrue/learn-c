= 汇编语言

== 汇编指令

=== hlt(暂停)

在计算机编程领域，"HLT" 是一条汇编语言指令的缩写，全称是 "Halt"。该指令的含义是让中央处理单元（CPU）进入停机状态或者说是暂停执行指令。当CPU执行到HLT指令时，它会停止当前的操作，并进入一个低功耗状态，直到接收到外部中断或者复位信号才会恢复执行。

在操作系统和嵌入式系统中，HLT指令通常用于降低能耗或在没有任务需要执行时暂停CPU。在实时操作系统中，如果没有需要立即处理的任务，可以使用HLT指令，以防止CPU空转浪费能量。

需要注意的是，HLT指令执行后，CPU处于停机状态，不会自动恢复执行。通常需要通过硬件中断或其他外部信号来唤醒CPU并继续执行程序。

=== iret

`iret` 是 x86 架构中的汇编指令，全称是 "Interrupt Return"，含义是用于从中断处理程序返回到原来的程序执行流。

当 x86 处理器执行中断服务例程（ISR，Interrupt Service Routine）时，它使用 `iret` 指令来返回到原来的程序。在中断服务例程中，处理器会自动保存一些寄存器的状态，包括标志寄存器（EFLAGS）、代码段选择子（CS）、指令指针（EIP）、数据段选择子（DS）、栈段选择子（SS）等。这样做是为了保护原来的程序状态，并在中断处理完成后正确恢复原来的状态。

执行 `iret` 指令时，处理器会弹出栈中的保存的状态信息，并将控制权返回到原来的程序的指令位置继续执行。`iret` 指令通常用于处理硬件中断、异常或软件中断等情况，确保中断处理后，CPU正确地恢复到原来的执行状态。

`iret` 指令是一个特权指令，只能在特权级别 0、1、2 中执行，也就是内核态（Ring 0）和一些受信任的特权级别中。在用户态（Ring 3）中，执行 `iret` 指令会导致处理器产生异常。

总结：`iret` 指令用于从中断处理程序返回到原来的程序执行位置，并恢复保存的寄存器状态，以确保正确的执行流程。

=== mfence

MFENCE 指令对于在该指令前发出的所有从内存加载和存储到内存的指令执行序列化操作。 这种序列化操作确保了在 MFENCE 指令之前以程序顺序排列的每个内存加载和存储指令在 MFENCE 指令之后的任何加载或存储指令之前变得全局可见。MFENCE 指令与所有加载和存储指令，其他 MFENCE 指令，任何 LFENCE 和 SFENCE 指令以及任何序列化指令（如 CPUID 指令）相关。MFENCE 指令不会序列化指令流。

弱排序内存类型可以通过一些技术（如乱序发射、预测读取、写组合和写折叠）来实现更高的处理器性能。数据消费者识别或知道数据是弱排序的程度在各种应用程序中不同，并且可能对生产此数据的系统不可知。 MFENCE 指令提供了一种性能高效的方式，可以确保产生弱排序结果的例程与使用该数据的例程之间的加载和存储排序。

处理器可以自由地从使用 WB、WC 和 WT 存储类型的系统内存区域中推测地提取和缓存数据。这种推测性提取可以随时发生，并且不与指令执行相关。因此，它与 MFENCE 指令的执行不相关；数据可以在执行 MFENCE 指令之前、期间或之后被推测性地带入缓存中。

该指令在非64位模式和64位模式下的操作相同。指令上面的操作码规定了ModR/M字节为F0。对于该指令，处理器忽略ModR/M字节的r/m字段。因此，MFENCE 由任何形如0F AE Fx的操作码编码，其中x在0-7范围内。

=== lock

LOCK 前缀是一种用于将指令转换成原子性操作的 IA-32 和 Intel 64 处理器指令前缀。当处理器执行带有 LOCK 前缀的指令时，会发出 LOCK# 信号，此信号保证当前处理器在访问共享内存时具有独占权，其他处理器需要等待 LOCK# 信号解除后才能访问这块共享内存区域，从而保证操作的原子性和一致性。

在大多数 IA-32 和所有 Intel 64 处理器中，即使没有显式使用 LOCK 前缀，也可以实现类似的原子性操作。这是因为内部硬件机制通常会自动检测并保持对共享内存的独占访问权限，从而避免数据竞争和其他线程安全问题。

LOCK 前缀只能用于以下一组指令以及对应的内存目的操作数形式：ADD、ADC、AND、BTC、BTR、BTS、CMPXCHG、CMPXCH8B、CMPXCHG16B、DEC、INC、NEG、NOT、OR、SBB、SUB、XOR、XADD 和 XCHG。如果将 LOCK 前缀用于其中的一个指令且源操作数是存储器操作数，则可能会产生未定义的操作码异常（\#UD）。如果将 LOCK 前缀用于不在该列表中的任何指令，则也会产生未定义的操作码异常。除此之外，无论是否使用 LOCK 前缀，XCHG 指令总是会发出 LOCK# 信号。

LOCK 前缀通常与 BTS 指令一起使用，用于在共享内存环境中执行读取修改写入（read-modify-write）操作。由于 LOCK 前缀和硬件机制保证了内存访问的原子性和一致性，因此可以确保多线程或多进程环境下的数据访问顺序正确。

需要注意的是，LOCK 前缀的操作与内存区域的对齐方式无关，即可以对任意不对齐的内存区域进行操作。此外，LOCK 前缀的操作在 IA-32 和 Intel 64 模式下具有相同的行为。

从P6系列处理器开始，当 LOCK 前缀被添加到一条指令上，同时该指令要访问的内存区域已经被处理器的内部高速缓存缓存时，通常不会发出 LOCK# 信号。取而代之的是，只有处理器的内部缓存被锁定。在这种情况下，处理器的高速缓存一致性机制会确保操作在内存方面是原子性的。在《Intel® 64 和 IA-32 Architectures 软件开发手册》第3A卷第9章的“锁定操作对内部处理器缓存的影响”一节中可获得更多关于缓存锁定的信息。

=== int

在汇编语言中，`int`是一个重要的指令，用于触发软中断（Software Interrupt）。在x86架构的计算机上，`int`指令被用于在用户态程序中请求操作系统提供的服务，进入内核态执行特定的系统调用。

`int`指令通常需要一个参数，即中断号（Interrupt Number）。不同的中断号对应着不同的系统调用。当`int`指令被执行时，CPU会暂停当前的执行流程，从用户态切换到内核态，然后跳转到预定义的中断处理程序（Interrupt Handler）来处理请求的服务。

在x86架构上，常见的`int`指令格式为：

[source,assembly]
----
int interrupt_number
----

其中，`interrupt_number`是一个用于表示具体中断号的整数值。

例如，执行`int 0x80`指令会触发Linux系统中的系统调用。在早期的Linux版本中，使用`int 0x80`来进行系统调用是一种常见的方式，但在较新的64位系统中，通常会使用更现代的方式，如通过`syscall`指令进行系统调用。

请注意，不同的操作系统和体系结构可能具有不同的中断号和中断处理方式。因此，在不同的环境中，`int`指令可能具有不同的功能和含义。在实际编程中，为了实现跨平台兼容性，通常使用操作系统提供的高级接口（如C库的函数），而不直接使用汇编语言中的`int`指令。

==== int 指令引发 CPU 从用户态切换到内核态，是硬件机制吗

实际上，`int` 指令本身并不是引发CPU从用户态切换到内核态的硬件机制。`int`指令是一条特定的汇编指令，用于触发软中断（Software Interrupt），它是由CPU硬件支持的。但是，它是软件向硬件发起中断的一种方式，并不能直接导致用户态到内核态的切换。

在x86架构的计算机上，从用户态切换到内核态实际上是通过处理器特权级别（Privilege Level）和特定硬件机制来实现的。x86架构定义了四个特权级别，分别是Ring 0（内核态）、Ring 1、Ring 2和Ring 3（用户态）。Ring 0拥有最高特权级别，Ring 3拥有最低特权级别。

当用户态程序执行`int`指令时，它会触发一个软中断，导致CPU进入中断处理流程。在中断处理过程中，CPU会检查中断向量（Interrupt Vector），找到与之对应的中断处理程序，这个中断处理程序位于操作系统的内核空间（Ring 0）。

在处理中断的过程中，硬件会自动将CPU的特权级别从用户态切换到内核态，将当前的特权级别压入堆栈，并加载新的特权级别。这样，CPU就处于内核态，并且具有较高的特权级别，可以访问受保护的内核空间，执行特权操作。

所以，可以说，`int`指令触发了一个软中断，而特权级别的切换是由硬件机制实现的。通过这种方式，CPU在处理软中断时从用户态切换到内核态，允许操作系统在内核态下执行相应的中断处理程序和系统调用。

==== 8.2.4 用户模式和内核模式

为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制 一个应用可以执行的指令以及它可以访问的地址空间范围。
处理器通常是用某个控制寄存器中的一个模式位(mode bit)来提供这种功能的，该寄 存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中(有时叫 做超级用 户模式)。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以 访问系统中的任何内存位置。
没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令 (privileged instruction), 比如停止处理器、改变模式位，或者发起一个 I/O操作。也不允许 用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致 命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。
运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的 唯一方法是通过诸如中断、故障或者陷人系统调用这样的异常。当异常发生时，控制传递 到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中， 当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。

==== CR0

在x86架构的处理器中，CR0（Control Register 0）是一个重要的控制寄存器，其中包含了一个模式位 PE（Protection Enable），用于控制处理器的保护模式。

当PE位被置为1时，处理器处于保护模式（Protection Mode），并且特权级别被划分为四个级别：Ring 0（内核态）、Ring 1、Ring 2和Ring 3（用户态）。在保护模式下，CPU运行在Ring 0时拥有完整的特权，可以访问所有资源和指令，而Ring 3的特权最低，受到最多的限制。

当PE位被置为0时，处理器处于实模式（Real Mode），特权级别没有划分，所有的程序运行在同一特权级别下，并且CPU可以访问所有的物理内存。实模式是早期的x86处理器模式，在这个模式下，CPU不能提供内存保护和多任务支持。

为了从实模式切换到保护模式，操作系统在启动时需要设置CR0寄存器的PE位为1，这样处理器就能够运行在保护模式下，并启用特权级别划分和内存保护。

进程的特权级别管理通常由操作系统负责，当一个进程从用户态切换到内核态时，操作系统会通过设置处理器的特权级别，将进程切换到适当的特权级别，从而在内核态下执行需要的操作。在处理器的特权级别切换过程中，相关的控制寄存器的值会被保存和恢复，以确保特权级别的正确管理和切换。

== 函数片段

